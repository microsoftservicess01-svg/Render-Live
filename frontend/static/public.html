<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üé• Public Broadcast - Go Live</title>
  <style>
    body { font-family: Arial; background:#f7f9fb; padding: 20px; }
    h2 { text-align:center; }
    #chat { border:1px solid #ccc; height:220px; overflow-y:auto; padding:8px; border-radius:6px; background:#fff; }
    input, button { padding:8px; border-radius:6px; margin-top:5px; }
    video { width:90%; margin:4px; border-radius:8px; background:black; }
    #videos { text-align:center; margin-top:20px; }
    #goLive { background:#0b74ff; color:#fff; font-weight:bold; border:none; padding:10px 16px; border-radius:6px; cursor:pointer; }
    #goLive.stop { background:#ff3b30; }
    #status { text-align:center; margin-top:10px; font-weight:bold; color:#444; }
  </style>
</head>
<body>
  <h2>üåç Public Broadcast</h2>
  <div id="chat"></div>
  <input id="msg" placeholder="Say something..." /> 
  <button id="send">Send</button>

  <div id="videos">
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay muted playsinline style="display:none;"></video>
  </div>

  <div id="status">Waiting for live broadcast...</div>
  <div style="text-align:center;">
    <button id="goLive">üé¨ Go Live</button>
  </div>

  <hr>
  <button id="toPrivate">Join Private Broadcast</button>

  <script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>
  <script src="shared.js"></script>
  <script>
    token = localStorage.getItem('token');
    myId = localStorage.getItem('userId');
    if (!token) location.href = 'login.html';

    const socket = io(API_BASE, { path: '/socket.io' });
    const chat = document.getElementById('chat');
    const msg = document.getElementById('msg');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const goLiveBtn = document.getElementById('goLive');
    const statusEl = document.getElementById('status');

    let isLive = false;
    let pc = null;
    let stream = null;
    let broadcasterId = null;

    // === CHAT ===
    socket.on('connect', () => socket.emit('auth', token));
    socket.on('auth-ok', () => console.log('Connected to broadcast channel'));
    socket.on('public-message', m => {
      const p = document.createElement('p');
      p.textContent = `${m.from}: ${m.text}`;
      chat.appendChild(p);
      chat.scrollTop = chat.scrollHeight;
    });

    document.getElementById('send').onclick = () => {
      socket.emit('public-message', msg.value);
      msg.value = '';
    };

    // === GO LIVE ===
    goLiveBtn.onclick = async () => {
      if (isLive) {
        stopLive();
        return;
      }
      goLiveBtn.classList.add('stop');
      goLiveBtn.innerText = 'üü• Stop Live';
      isLive = true;
      broadcasterId = myId;
      socket.emit('go-live', { id: myId });
      await startBroadcast();
      statusEl.textContent = 'You are LIVE! Viewers are watching...';
    };

    function stopLive() {
      isLive = false;
      goLiveBtn.classList.remove('stop');
      goLiveBtn.innerText = 'üé¨ Go Live';
      socket.emit('stop-live', { id: myId });
      if (stream) stream.getTracks().forEach(t => t.stop());
      localVideo.style.display = 'none';
      statusEl.textContent = 'Stopped broadcasting.';
    }

    // === VIEWER ===
    socket.on('live-started', data => {
      broadcasterId = data.id;
      statusEl.textContent = 'üì° A broadcast is live! Connecting...';
      startViewer();
    });

    socket.on('live-stopped', () => {
      statusEl.textContent = '‚èπÔ∏è Broadcast ended.';
      if (remoteVideo.srcObject) remoteVideo.srcObject.getTracks().forEach(t => t.stop());
      remoteVideo.srcObject = null;
    });

    // === SIGNALING FOR WEBRTC ===
    socket.on('public-signal', async ({ from, sdp, candidate }) => {
      if (!pc) return;
      if (sdp) {
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        if (sdp.type === 'offer') {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('public-signal', { to: from, sdp: pc.localDescription });
        }
      } else if (candidate) {
        try { await pc.addIceCandidate(candidate); } catch(e){ console.error(e); }
      }
    });

    async function startBroadcast() {
      stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      localVideo.srcObject = stream;
      localVideo.style.display = 'block';
      pc = new RTCPeerConnection();
      stream.getTracks().forEach(track => pc.addTrack(track, stream));

      pc.onicecandidate = e => {
        if (e.candidate) socket.emit('public-signal', { to: 'all', candidate: e.candidate });
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('public-signal', { to: 'all', sdp: pc.localDescription });
    }

    async function startViewer() {
      pc = new RTCPeerConnection();
      pc.ontrack = event => remoteVideo.srcObject = event.streams[0];
      pc.onicecandidate = e => {
        if (e.candidate && broadcasterId)
          socket.emit('public-signal', { to: broadcasterId, candidate: e.candidate });
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('public-signal', { to: broadcasterId, sdp: pc.localDescription });
    }

    document.getElementById('toPrivate').onclick = () => location.href = 'private.html';
  </script>
</body>
</html>
